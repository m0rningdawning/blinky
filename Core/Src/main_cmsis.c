/**
  ******************************************************************************
  * @file           : main_cmsis.c
  * @brief          : A barebones example of CMSIS blinky
  * @author         : Pavlo Korolov
  ******************************************************************************
  */

#include "stm32f7xx.h"

// -----------------------------------------------------------------------------
// Simple delay loop (not precise, but ok for LED blinking)
//   CPU runs at 216 MHz (default Overdrive).
//   Roughly 1 ms =~ 12000 iterations of inner loop.
// -----------------------------------------------------------------------------
static void delay_ms(volatile uint32_t ms)
{
    const uint32_t loops_per_ms = 12000U;
    for (; ms > 0; --ms)
    {
        for (uint32_t i = 0; i < loops_per_ms; i++)
        {
            __NOP();
            __NOP();
        }
    }
}

// -----------------------------------------------------------------------------
// Initialize PB0, PB7, PB14 as push-pull outputs (LD1, LD2, LD3).
// -----------------------------------------------------------------------------
static void LED_Init(void)
{
	// Enable clock for GPIOB: AHB1ENR bit 1 (GPIOBEN)
    RCC->AHB1ENR |= (1U << 1);
    __DSB();

    // Configure PB0, PB7, PB14 as General Purpose Output
    // Each pin uses 2 bits in MODER: MODERy[2*y : 2*y+1]
    // 00 = input, 01 = output, 10 = AF, 11 = analog
    // Clear existing bits, then set to “01” (output).
    GPIOB->MODER &= ~((3U << (0 * 2))  |  // PB0
                      (3U << (7 * 2))  |  // PB7
                      (3U << (14 * 2)));  // PB14

    GPIOB->MODER |=  ((1U << (0 * 2))  |  // PB0 = 01
                      (1U << (7 * 2))  |  // PB7 = 01
                      (1U << (14 * 2)));  // PB14 = 01

    // Set output type to Push-Pull (default is 00, so we just clear any OTYPER bits)
    GPIOB->OTYPER &= ~((1U << 0) | (1U << 7) | (1U << 14));

    // No pull-up, pull-down: PUPDR[2*y:2*y+1] = 00
    GPIOB->PUPDR &= ~((3U << (0 * 2))  |
                      (3U << (7 * 2))  |
                      (3U << (14 * 2)));

    // Optionally initialize outputs to OFF (LED OFF because active-high)
    // Writing a 0 to ODR will keep LED off if the board drives LED on high.
    GPIOB->BSRR = ((1U << (0 + 16))  |   // reset PB0 (LD1 off)
                   (1U << (7 + 16))  |   // reset PB7 (LD2 off)
                   (1U << (14 + 16)));   // reset PB14 (LD3 off)
}

// -----------------------------------------------------------------------------
// Turn individual LEDs on/off. On Nucleo-F767ZI, these are active-high:
//   - LD1 ➞ PB0
//   - LD2 ➞ PB7
//   - LD3 ➞ PB14
// -----------------------------------------------------------------------------
static void LED_Write(uint8_t red, uint8_t green, uint8_t blue)
{
    // PB14 = Red (LD3)
    if (red)   { GPIOB->BSRR = (1U << 14);         } // set PB14 HIGH ➞ LED ON
    else       { GPIOB->BSRR = (1U << (14 + 16)); } // reset PB14 LOW ➞ LED OFF

    // PB0 = Green (LD1)
    if (green) { GPIOB->BSRR = (1U << 0);          } // set PB0 HIGH ➞ LED ON
    else       { GPIOB->BSRR = (1U << (0 + 16));  } // reset PB0 LOW ➞ LED OFF

    // PB7 = Blue (LD2)
    if (blue)  { GPIOB->BSRR = (1U << 7);          } // set PB7 HIGH ➞ LED ON
    else       { GPIOB->BSRR = (1U << (7 + 16));  } // reset PB7 LOW ➞ LED OFF
}

int main(void)
{
	// Autogenerated system init function
    SystemInit();

    // Init LEDs on GPIOB
    LED_Init();

    // Blink loop
    while (1)
    {
        LED_Write(1, 0, 0);
        delay_ms(500);

        LED_Write(0, 1, 0);
        delay_ms(500);

        LED_Write(0, 0, 1);
        delay_ms(500);

        LED_Write(1, 1, 1);
        delay_ms(500);

        LED_Write(0, 0, 0);
        delay_ms(500);
    }
}
